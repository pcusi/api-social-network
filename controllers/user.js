const User = require('../models/User');
const bcrypt = require('bcryptjs');
const moment = require('moment');
const jwt = require('jsonwebtoken');
const path = require('path');
const expiresIn = '2h';

/* function => create a new user with all the data from the model */
function _newUserCreated(req, res) {
    let {
        names,
        surnames,
        username,
        age,
        password,
    } = req.body;
    let u = new User();
    u.names = names;
    u.surnames = surnames;
    u.username = username;
    u.age = age;
    u.created_at = moment().unix();


    if (!password) {
        return res.status(403).send({
            message: 'La contrase침a es necesaria!'
        })
    }


    /* now we need encrypt the new user password, we're going to use the library bcrypt */
    bcrypt.hash(password, 10).then(hashed => {
        u.password = hashed;
        /* save user */
        u.save().then(user => {

            res.status(200).send({
                user: user
            });
        }).catch(err => res.status(500).send({
            err,
            message: 'El campo email ha sido duplicado!'
        }));
    }).catch(err => res.status(401).send({
        message: err + ', la contrase침a no pudo ser encriptada, porque no se ha colocado ninguna'
    }));
}

async function _userLogIn(req, res) {
    let {
        email,
        password
    } = req.body;
    /* creating a variable with contains the findOne from the model */
    let user = await User.findOne({
        'email': email
    });
    /* if user exists create a TOKEN */
    if (user) {
        /* token generated by the user logIn */
        var token = jwt.sign({
            sub: user._id, //contains the user._id from the Schema 'User'
            role: 'user_basic', //role basic in the platform
        }, '$ULTRA_SECRET_2K20$', { //secret text for the token
            expiresIn
        });
        /* now compare the password from the req body (password) and the user password, remember
        the let user variable, contains the query for any user */
        bcrypt.compare(password, user.password).then(logged => {
            if (logged) {
                res.status(200).send({
                    token,
                    user
                });
            } else {
                user.password = null;
                res.status(200).send({
                    user
                });
            }
        }).catch(err => res.status(500).send({
            err
        }));
    } else {
        res.status(401).send({
            message: 'Has colocado mal tus datos!'
        });
    }
}

async function _userPhotoCreated(req, res) {
    let id = req.params.id;

    if (req.user != id) {
        try {
            return res.status(401).send({
                message: 'No tienes autorizaci칩n'
            });
        } catch (err) {
            return res.status(404).send({
                message: 'Error'
            })
        }
    }

    if (req.files) {
        let photo = req.files.photo.path;
        await User.findByIdAndUpdate(id, {
            'photo': photo
        }, {
            new: true
        }).then(user => {
            return res.status(200).send({
                user
            });
        }).catch(err => res.status(500).send({
            err
        }));
    } else {
        res.status(401).send({
            message: 'No se subi칩 la imagen'
        })
    }
}

module.exports = {
    _newUserCreated,
    _userLogIn,
    _userPhotoCreated
}